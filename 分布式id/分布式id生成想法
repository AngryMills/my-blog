大家好，我是烤鸭：
	最近想开发一个分布式id解决方案，网上看了看大家的实现，其中比较有名的是雪花算法(百度和美团分别对其进行了优化改造)。

1.  雪花算法
	我们先看下雪花算法,生成的64位的Long类型的值。
	64位分布: 41位 时间戳。 5位 workerid(机器码)和5位dataCenterid(数据id)
	12位自增。2 ^ 12 同一毫秒，支持4k个码。
	也就是同一个workerid和dataCenterid 在一秒内可以生成400w个不重复的id,不用想了,每秒400w,144亿/小时。
	就目前的业务量,可能很少有公司能达到这种程度。
	雪花算法的局限在于依赖系统的时间,如果系统时间出现问题(回拨),就可能导致生成的id相重复。
	还有个不太方便的地方在于,workerid和datacenterid需要提前指定。也就是如果想保证在整个业务全局id唯一,就需要自己保证两个id的唯一性(由于各5位,最大值为2^10=1024)。
	1024也是一个瓶颈。

2.  百度uid-generator项目
    解决了系统时钟回拨的问题，采用数据库维护 workerid (项目启动后,ip和port 存入数据库后生成workerid环形数组,重复利用)。
    id生成,每次生成一批id放入缓冲数组,游标超过队列阈值,就再次获取。
    对于 uid-generator 中的 workId，占用了22个 bit 位，时间占用了28个 bit 位，序列化占用了13个 bit 位(2^13=8192,每秒并发8192)。
    支持2^22 ≈ 420w的workId，同一个应用每重启一次就会消费一个 workId。
    需要注意的是，和原始的 snowflake 不太一样，时间的单位是秒，而不是毫秒。
    采用了workid复用的方式,同时扩展了workid的位数,对应的代价就是减少了并发。这个还是要看具体的场景，如果机器比较少的话，可以采用原始的方式,1024个workerid够用，换来的是少量机器的高并发。

3.	美团的leaf项目
	具体可以参考美团的博客：https://tech.meituan.com/2019/03/07/open-source-project-leaf.html
	按照他们的博客介绍，leaf的问题主要在于Leaf服务Shutdown时产生的号段浪费，强依赖 数据库(数据库本身就是高并发的瓶颈,只能做好容错方案了)。
	文章是去年写的，不知道这些问题都修复了没。
	源码地址：https://github.com/Meituan-Dianping/Leaf
	leaf的server不止有mysql还有zk和redis，丰富了机器ID的生成和获取方式，实例编号可以存储起来反复使用，不再是数据库单调增长这一种了。

4.  实现思路
	大佬们把路都铺好了,现在只差走了。想简化使用中间件,侵入性低。还要保证高可用和id不重复。
	中间件采用zk,用于workerid记录和cursor记录,client端采用buffer号段接收。
	client端每次生成id时，传ip和端口,ip和端口记录在zk,用同一个key维护,保持环形列表范围内自增。
	生成id依赖server机器本地雪花算法(每秒400w),支持机器水平扩展(前期考虑配置网址,利用nginx做负载,也就是先不考虑超过每秒400w的问题了)。
	每次调用生成后返回号段范围(美团遇到过耗时尖刺的问题,某个时刻请求量激增。如果号段范围设置过大,导致buffer空间浪费。buffer范围大小设置是个问题。也先不考虑太极端的情况)。
	业务只需要引入 client.jar ,底层采用netty调用,如果server调用失败会默认按照client的算法执行(利用hostname或者ip+端口计算workerid和dataCenterid,本机的方式在不配置hostname的时候不能保证全局唯一)。



