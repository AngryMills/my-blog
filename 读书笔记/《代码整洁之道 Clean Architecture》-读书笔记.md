大家好，我是烤鸭：
关于《代码整洁之道》，记录一下读书笔记。
@[TOC]( 代码整洁之道)
#  第一章 整洁代码
## 整洁代码的艺术
优雅而高效。代码逻辑直接了解，bug无处可藏。尽量减少依赖关系，性能调优。
应用单元测试和验收测试，有意义的命名，明确的定义和提供清晰、尽量少的API。
通过所有测试、没有重复代码，提高表达力。
# 第二章 有意义的命名
## 避免误导
比如 XYZControllerEfficientHandlingOfStrings 和 XYZControllerEfficientStorageOfStrings。
## 有意义的区分
反例：
比如  字母 O和 I 和 数字 0 和 1
比如  getAccount 和  getAccounts 和 getAccountInfo ，不知道这三个方法的区别
## 使用读得出来和可搜索的名字
反例：
genhydhms  一个生成年月日时分秒的方法
应该避免下面这种命名不知道什么意义的代码。
```
for (int i = 0; i < s; i++) {
         s +=1;
}
```
## 避免使用编码
反例：
成员变量前缀加 m_ 比如 m_dsc。
不对接口命名
反例：
比如 IShapeFactory，按照阿里规范，命名提现设计模式，直接叫 ShapeFactory即可。

# 第三章 函数
**函数要短小**(阿里规范80行，作者建议不要超过120行)；
**只做一件事**(单一原则)；
函数语句处在**同一抽象层级且自顶向下**(比如getHtml()和PathParser.render(pagePath)就不是同一抽象层级)；
**switch或if/else** 语句不要做过多的逻辑处理(容易违反单一原则和开闭原则);
**起个好名字**(不怕长，要有描述性)；
**函数参数尽量少**，不要标识参数(需要的话用两个方法表示)，多参数时采用对象，可变参数不要超过三元，动词和关键词(比如write(name)或者writeField(name),可以更好的表示函数和参数的意思)；
**避免函数的副作用**(函数的变量范围过大之类的(成员变量定义为全局变量))，尽量避免输出参数；
**分隔指令与询问**(也是单一原则的体现,把检查和设值放到一个函数的问题，比如if(set("username","unclebob")){...}应换成if(attributeExists(username){set("username","unclebob"))})))；
**使用异常代替错误码**(这个还是要看业务场景,按照阿里规范第三方调用的时候需要返回错误码,如果是内部服务调用可以抛异常)，抽离try catch 代码块，catch finally 不要做其他事，定义错误枚举；
**减少重复代码**；
**遵循结构化编程**，小函数偶尔使用return、break或continue没有坏处；
没人一上来就能按照规范写代码，打磨代码，按照本章规则组装函数。
# 第四章 注释
**好的代码可以代替注释** ，比如 employ.isEligibleForFullBenefits 方法名称即注释
**必要的注释**，1. 法律信息 2. 提供信息 3. 对意图的注释（对返回值的解释） 4. 阐释：a.compareTo(b) == -1 // a < b 5. 给下一个看这个代码的人的提示 6. TODO 7. 强调 8. 公共API的javadoc 
**坏注释**，1. 多余的注释 2. 误导注释 3. 循规（不需要所有的javadoc）4. 日志式注释 5. 废话 6. 位置标记（// Action /////////////////）7. 注释和代码没有隔行 8. 注释的代码 9. HTML、非本地的(代码变量)、信息过多、非公共Javadoc。 这段感觉作者写的就很废话了...
复杂的方法有注释，简单的不需要（函数名称要清晰），需要的地方加注释(作者信息、Javadoc、TODO 等)
# 第五章 格式
**垂直格式** 像报纸学习（名称简单且一目了然）、代码间隔（不同方法中间会有空行）、靠近（有联系的变量间不需要空行）、变量声明的位置（本地变量在函数顶部、循环语句的变量在循环体中声明、实体变量在类顶部声明、相关函数放到一起、概念相关放到一起）

横向注意分隔(函数名和左括号不加空格，函数调用括号中参数逗号分隔)

```
private void measure(String line){
	lineCount++;
	int lineSize = line.length();
	totalChars += lineSize;
	lineWidthHistogram.addLine(lineSize, lineCount);
	recordWidestLine(lineSize);
}
```

不对齐的声明和赋值(变量左对齐)

if、while 要缩进

while或for语句体为空时，不写循环体的结束分号最好换行（阿里规范是空循环也要有{ }）

团队规则很重要（花很小的时间统一团队的代码规范）

# 第六章 对象和数据结构

**数据抽象** 不暴露细节且符合业务场景

**数据、对象的反对称性** 面向过程便于不改变既有数据结构下添加新函数，面向对象便于不改动既有函数前提下添加新类。（过程代码不易添加新数据结构，面向对象代码不易添加新函数）

**得墨忒耳律** 模块不应该了解调用对象的内部情形。比如 类C的方法f只应该调用以下对象的方法：

C、由f创建的对象、作为参数传递给f的对象、由C的实体变量持有的对象，方法不应该调用由任何函数返回的对象的方法。是数据结构还是对象（数据结构无所谓）、一半数据结构一半对象（公共方法导致私有变量公有化，不安全）、隐藏结构（只暴露对象的方法、隐藏内部和实现）

**数据传送对象** DTO（data transfer objects）业务流转对象、VO（展示层对象）、DO（数据层交互对象）不参杂业务逻辑

**小结** 对象暴露行为、隐藏数据，数据结构暴露数据、没有明显的行为。面向对象和面向过程看具体的场景选择。

# 第七章 错误处理

**使用异常而非错误码** （内部服务调用可以使用抛出异常，对外提供的接口最好还是返回错误码）

**先写try-catch-finally语句** 定义范围，方便满足测试

**使用不可控异常** checked exception（可控异常），异常和方法绑定，但是违反了开闭原则。如果在方法中抛出课可控异常，需要在抛出异常处之间的每个方法签名中声明该异常。如果写一套关键代码库，可控异常有用，必须捕获异常。但一般应用开发，依赖成本高于收益。

**给出异常发生的环境说明** 记录错误的堆栈信息

**依调用者需要定义异常类**  封装第三方调用api，确保返回的异常类型，简化代码

**定义常规流程** 特例模式，创建一个类或配置一个对象处理特例，就不用应付异常行为了。比如下面的代码，处理业务逻辑没有餐食消耗的时候，总账加上补贴。

```
try{
	MealExpenses expenses.getTotal; = expenseReportDAO.getMeals();
	m_total = expenses.getTotal;
}catch(MealExpensesNotFound e){
	m_total = getMealPerDiem();
}
```

应该把catch和业务代码分开。定义特例的类。

```
public class PerDiemMealExpenses implements MealExpenses{
	public int getTotal(){
		// renturn the per diem default
	}
}
```

**别返回null值** 避免NPE的最好方式，不返回null，返回空集合或者空对象(实际场景协同开发时很难保证)

**别传递null值** 避免NPE和其他运行时问题

# 第八章 边界

**使用第三方代码** 比如 java.util.Map，有一个对象想用Map做数据结构，还不要暴露细节(隐藏Map)，可以写成下面这样。

```
public class Sensors{
	private Map sensors = new HashMap();
	public Sensor getById(String id){
		return (Sensor)sensors.get(id);
	}
}
```

**浏览和学习边界** 

**学习测试好处不只是免费** 确保第三方程序包正常工作

**使用尚不存在的代码** 先定义API，后完成代码细节

**整洁的边界** 通过引入第三方边界接口的位置管理第三方边界。比如 Map 包装 或者 Adapter 模式。

# 第九章 单元测试

**TDD 三定律** (每天编写数十个测试用例，代码量大，不易管理)

在编写不能通过的单元测试前，不可编写生产代码。

只可编写刚好无法通过的单元测试，不能编译也算不通过。

只可编写刚好足以通过当前失败测试的生产代码。

**保持测试整洁** 测试代码和生产代码一样重要。测试覆盖率越高，越不会出问题。

**整洁的测试** 可读性：明确、简洁、足够的表达力。

构造-操作-检验(build-operate-check)模式。第一个环节 构造测试数据，第二个环节操作测试数据，第三个环节检验操作是否得到期望结果。

针对特定场景封装api符合特定的测试语言。

测试和生产环境代码的不同标准，测试用例可以使用 String += 的方式拼接字符串，不需要考虑性能。

每个测试用例都应该有断言，但要限制数量。（正常开发也推荐断言代替if、else）。每个测试用例要清晰，只测试一个概念，每个概念的断言数量要控制。

整洁的规则 FIRST

- first 快速。
- independent 独立。用例间相互独立，单独运行。
- repeatable 可重复。可在不同环境下重复通过。
- self-validating 自足验证。应该有布尔值输出，成功失败一目了然。
- timely 及时。用例应及时编写。单元测试应该恰好在其通过的生产代码之前编写。

# 第十章 类











